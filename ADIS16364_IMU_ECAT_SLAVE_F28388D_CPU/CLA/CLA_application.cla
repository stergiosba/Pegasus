//
// Included Files
//
#include "CLA_shared.h"
#define APP 1

#if APP == 1
    #include <app_cf.h>
#elif APP == 2
    #include <app_kf.h>
#endif


// u32_cla_delay
// Custom CLA nearly precise delay function. Used with uint32_t (unsigned long)
// Input: A delay in us (microseconds) and the cycles are calculated inside
// 6.5 cycles per loop 1 + 5 cycles calculation overhead
// Delay_us = (6.5*cycles+5)/200
// Based on the maximum 200 Mhz clock of F28388D and Optimization level 2+.
//
static inline void u32_cla_delay(uint32_t delay_us)
{
    //Initializing index
    uint32_t i;
    // Calculating the cycles
    uint32_t counter = (uint32_t) (200*delay_us-5)/6.5f;

    //
    // Loop 1
    //
    for (i=0;i<counter;i++)
    {
        //__mnop() CLA intrinsic translates into 1 NOP/cycle
        __mnop();
    }
}// End Of u32_cla_delay()

static inline uint16_t SensorRead_cla(uint16_t Reg, uint16_t NumBits)
{
    //
    // Initialize Results' Variable
    //
    uint16_t Sensrd = ADIS16364_NULL_COMMAND;

    //
    // Left Shift Register's Value to comply with IMU's SPI Transfer Form
    //
    Reg <<= 8;

    //
    // Request the specified Register's Contents
    //
    SPI_writeDataBlockingNonFIFO(SPI_config.spi_base, Reg);

    //
    // Data Ready Delay
    //
    u32_cla_delay(30U);

    //
    // Dummy Transfer to update SPI's incoming register
    //
    SPI_writeDataNonBlocking(SPI_config.spi_base, ADIS16364_NULL_COMMAND);

    //
    // Data Ready Delay
    //
    u32_cla_delay(30U);

    //
    // Acquire SPI incoming Register's Contents
    //
    Sensrd = SPI_readDataBlockingNonFIFO(SPI_config.spi_base);

    //
    // Isolate the Register's Significant Bits
    //
    Sensrd &= (0xFFFF >> (SBITS16 - NumBits));

    //
    // Acquire SPI incoming Register's Contents
    //
    return Sensrd;

}   // End Of SensorRead()


static inline void RegisterWrite_cla(uint16_t Reg, uint16_t Value)
{
    //
    // Initialize Register's Write Command Variable
    //
    uint16_t Cmd = ADIS16364_NULL_COMMAND;

    //
    // Combine value & Register's address to a single Write Command
    //
    Cmd |= Reg;

    //
    // Left Shift Register's Value to comply with IMU's SPI Transfer Form
    //
    Cmd <<= 8;

    //
    // Form the Register's Write Command
    //
    Cmd |= (0x8000 | Value);

    //
    // Execute SPI Transfer
    //
    SPI_writeDataBlockingNonFIFO(SPI_config.spi_base, Cmd);

    //
    // Data Ready Delay
    //
    u32_cla_delay(50U);

}   // End Of RegisterWrite()


static inline float RawToReal_cla(uint16_t Raw, float RegScale, uint16_t NumBits, uint16_t Sign)
{
    //
    // Mask for Significant Bits
    //
    uint16_t Mask = 0xFFFF << (NumBits - 1);

    //
    // Signed Floating Point Unscaled Reading Initialization
    //
    float Sens;

    //
    // Register's Value is Signed
    //
    if (Sign)
    {
        //
        // Make Sign Negative & Reading Floating Point
        //
        if (Raw & Mask)
        {
            Sens = -RegScale * ((uint16_t)(~(Raw | 0xFFFF << NumBits)) + 1.0f);
        }
        else
        {
            Sens = (RegScale * Raw);
        }
    }

    //
    // Register's Value is Unsigned
    //
    else
    {
        Sens = (float)Raw;
    }

    return Sens;

}   // End Of RawToReal()

static inline void BurstRead_cla()
{
    //
    // Burst Registers' Significant Bits
    //
    uint16_t SBits[11] = { 12, 14, 14, 14,
                           14, 14, 14, 12,
                           12, 12, 12 };

    //
    // Raw Burst Readings' Vector
    //
    uint16_t Burst[11] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

    //
    // Loop Counter Initialization
    //
    uint16_t i;

    //
    // Burst Registers' Sign Types
    //
    uint16_t Sign[11] = { 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0 };

    //
    // Burst Registers' Scales
    //
    float RegScale[11] = { 1.0f, 0.05f, 0.05f,
                           0.05f, 1.0f, 1.0f,
                           1.0f, 0.136f, 0.136f,
                           0.136f, 1.0f };

    //
    // Execute Burst Command SPI Transfer
    //
    SPI_writeDataBlockingNonFIFO(SPI_config.spi_base, ADIS16364_BURST_COMMAND);

    //
    // Data Ready Delay
    //
    u32_cla_delay(20U);

    //
    // Acquire Burst Mode Readings
    //
    for (i = 0; i <= 10; i++)
    {
        //
        // Dummy Transfer to update SPI's incoming register
        //
        SPI_writeDataBlockingNonFIFO(SPI_config.spi_base, ADIS16364_NULL_COMMAND);

        //
        // Data Ready Delay
        //
        u32_cla_delay(20U);

        //
        // Acquire SPI incoming Register's Contents
        //
        Burst[i] = SPI_readDataBlockingNonFIFO(SPI_config.spi_base);

        //
        // Isolate the Register's Significant Bits
        //
        Burst[i] &= (0xFFFF >> (16 - SBits[i]));
    }
    //
    // Iterate the Acquired Raw Readings
    //

    for (i = 0; i <= 10; i++)
    {
        //
        // Translate Raw Readings to the Actual ones
        //
        g_SensBurst[i] = RawToReal_cla(Burst[i], RegScale[i], SBits[i], Sign[i]);
    }
}   // End Of BurstRead_cla()

//
// CLA Task 1 is responsible for the MCU-IMU communication and the attitude estimation
//
__interrupt void Cla1Task1 ( void )
{
    //
    // Perform a burst read
    //
    BurstRead_cla();

    //
    // Data comes in with every EtherCAT cycle therefore dt=ecat_cycle=1/ecat_frequency (2.5 kHz), needed for integration
    //
    float dt = (float) 1/2500;

    //
    // Complementary filter weight
    //
    float cfk = 0.98;

    //
    // Perform a complementary filter sensor fusion, found inside application.h file.
    //
    //RESTART_CLOCK;

    #if APP == 1
        Complementary_Filter(cfk, dt);
    #elif APP == 2
        Q_Complementary_Filter(cfk, dt);
    #endif
    //READ_CLOCK(ulCycleCount2);
}

__interrupt void Cla1Task2 ( void )
{
    RESTART_CLOCK;
    uint16_t RegValue = SensorRead_cla(SENS_AVG, SBITS16);
    READ_CLOCK(ulCycleCount1);
    //
    // Create the Desired Taps' Set Command
    //
    volatile uint16_t Cmd = ((RegValue & 0xFFF8) | (uint16_t)g_ActiveTaps);

    //
    // Execute the requires SPI Transfers to set the Taps
    //
    RegisterWrite_cla(SENS_AVG, (0x00FF & Cmd));
    RegisterWrite_cla(SENS_AVG + 0x0001, ((0xFF00 & Cmd) >> 8));

    //
    // Performing Bias Null Calibration only in Bias Calibration Mode.
    // g_ActiveMode is controlled via LAE_CONTROL0x7000.IMU_flags by the user.
    //
    if (g_ActiveMode == IMU_BIAS_CALIBRATION_MODE)
    {
        SPI_writeDataBlockingNonFIFO(SPI_config.spi_base, ADIS16364_NULL_BIAS_COMMAND);
    }
}

__interrupt void Cla1Task3 ( void )
{

}

interrupt void Cla1Task4 ( void )
{

}

interrupt void Cla1Task5 ( void )
{

}

interrupt void Cla1Task6 ( void )
{

}

interrupt void Cla1Task7 ( void )
{

}

interrupt void Cla1Task8 ( void )
{

}

//
// End of file
//
