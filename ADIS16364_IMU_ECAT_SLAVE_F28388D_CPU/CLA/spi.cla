//
// Included Files
//
#include "CLA_shared.h"
#include "ADIS16364.h"


extern void cla_test_func(void);

static inline void cla_delay(uint16_t delay_us)
{
    uint16_t i;
    for (i=0;i<delay_us;i++)
    {
        __asm(" MNOP");
    }
}

static inline float RawToReal_cla(uint16_t Raw, float RegScale, uint16_t NumBits, uint16_t Sign)
{
    //
    // Mask for Significant Bits
    //
    uint16_t Mask = 0xFFFF << (NumBits - 1);

    //
    // Signed Floating Point Unscaled Reading Initialization
    //
    float Sens;

    //
    // Register's Value is Signed
    //
    if (Sign)
    {
        //
        // Make Sign Negative & Reading Floating Point
        //
        if (Raw & Mask)
        {
            Sens = -RegScale * ((uint16_t)(~(Raw | 0xFFFF << NumBits)) + 1.0f);
        }
        else
        {
            Sens = (RegScale * Raw);
        }
    }

    //
    // Register's Value is Unsigned
    //
    else
    {
        Sens = (float)Raw;
    }

    return Sens;

}   // End Of RawToReal()

static inline void BurstRead_cla()
{
    //
    // Burst Registers' Significant Bits
    //
    uint16_t SBits[11] = { 12, 14, 14, 14,
                           14, 14, 14, 12,
                           12, 12, 12 };

    //
    // Raw Burst Readings' Vector
    //
    uint16_t Burst[11] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

    //
    // Loop Counter Initialization
    //
    uint16_t i;

    //
    // Burst Registers' Sign Types
    //
    uint16_t Sign[11] = { 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0 };

    //
    // Burst Registers' Scales
    //
    float RegScale[11] = { 1.0f, 0.05f, 0.05f,
                           0.05f, 1.0f, 1.0f,
                           1.0f, 0.136f, 0.136f,
                           0.136f, 1.0f };

    //
    // Execute Burst Command SPI Transfer
    //
    SPI_writeDataBlockingNonFIFO(SPI_config.spi_base, 0x3E00);

    //
    // Data Ready Delay
    //
    cla_delay(300U);

    //
    // Acquire Burst Mode Readings
    //
    for (i = 0; i <= 10; i++)
    {
        //
        // Dummy Transfer to update SPI's incoming register
        //
        SPI_writeDataBlockingNonFIFO(SPI_config.spi_base, 0x0000);

        //
        // Data Ready Delay
        //
        cla_delay(300U);

        //
        // Acquire SPI incoming Register's Contents
        //
        Burst[i] = SPI_readDataBlockingNonFIFO(SPI_config.spi_base);

        //
        // Isolate the Register's Significant Bits
        //
        Burst[i] &= (0xFFFF >> (16 - SBits[i]));
    }
    //
    // Iterate the Acquired Raw Readings
    //

    for (i = 0; i <= 10; i++)
    {
        //
        // Translate Raw Readings to the Actual ones
        //
        g_SensBurst[i] = RawToReal_cla(Burst[i], RegScale[i], SBits[i], Sign[i]);
    }
}   // End Of BurstRead_cla()


__interrupt void Cla1Task1 ( void )
{
    //
    // Perform a burst read
    BurstRead_cla();
    //

    //
    // Attitude estimation with Complementary Filter (CF)
    //
    // Data comes in with every EtherCAT cycle therefore dt=ecat_cycle=1/ecat_frequency (2.5 kHz)
    float dt = (float) 1/2500;
    float pi = 3.14159265359f;


    // Body rates measured by the gyroscopes
    float p = g_SensBurst[1];
    float q = g_SensBurst[2];
    float r = g_SensBurst[3];

    // Precalculating trigonometrics to speed up computations, CLA math needs angles in rads.
    float sin_phi = CLAsin(g_Attitude[0]*pi/180);
    float cos_phi = CLAcos(g_Attitude[0]*pi/180);
    float sin_theta = CLAsin(g_Attitude[1]*pi/180);
    float cos_theta = CLAcos(g_Attitude[1]*pi/180);
    float tan_theta = CLAdiv(sin_theta,cos_theta);
    float sec_theta = CLAdiv(1,cos_theta);

    //
    // Euler kinematics for the body rates from the Body Frame (B) to Inertial frame (I)
    // w_I = E*w_B *E is not a rotation matrix it is actually singular when theta (pitch angle) is 90 degrees.
    // w_I = [phi_dot, theta_dot, psi_dot]
    // w_B = [p, q, r]
    //
    float phi_dot = (p+q*sin_phi*tan_theta+r*cos_phi*tan_theta);
    float theta_dot = (q*cos_phi-r*sin_theta);
    float psi_dot = (p+q*sin_phi*sec_theta+r*cos_phi*sec_theta);

    //
    // Zero linear acceleration assumption (Accelerometer only measures the generalized gravity vector)
    // G: Generalized gravity vector
    // g: Gravity vector in the inertial frame = [0 0 -1] in g_SensBurst
    // R_BI: Rotation matrix from Body frame (B) to Inertial frame (I)
    // G = R_BI*g
    //
    float rollAcc = CLAatan(CLAdiv(g_SensBurst[5], g_SensBurst[6])) * 180 / pi;
    float pitchAcc = CLAatan(CLAdiv(-g_SensBurst[4],sin_phi*g_SensBurst[5]+cos_phi*g_SensBurst[6]))* 180 / pi;

    //
    // Simple Euler integration with Complementary filter sensor fusion.
    // x_est = k*integral(w_I)+(1-k)x_a
    // x_a = [rollAcc, pitchAcc] : The angles of the generalized gravity vector measured by the accelerometer with the above assumption
    // k: Weight factor for the Low pass filter(gyro) and 1-k for the High pass filter(accelerometer).
    //
    float k = 0.98;
    g_Attitude[0] = k*(g_Attitude[0]+dt*phi_dot)+(1-k)*rollAcc;
    g_Attitude[1] = k*(g_Attitude[1]+dt*theta_dot)+(1-k)*pitchAcc;
    g_Attitude[2] = g_Attitude[2]+dt*psi_dot;
}

__interrupt void Cla1Task2 ( void )
{
    uint16_t i;
    for (i = 0; i <= 10; i++)
    {
        //
        // Internal Reset of IMU measurements
        //
        g_SensBurst[i] = 0;
    }

    for (i = 0; i <= 2; i++)
    {
        //
        // Internal Reset of attitude estimates
        //
        g_Attitude[i] = 0;
    }
}

interrupt void Cla1Task3 ( void )
{

}

interrupt void Cla1Task4 ( void )
{

}

interrupt void Cla1Task5 ( void )
{

}

interrupt void Cla1Task6 ( void )
{

}

interrupt void Cla1Task7 ( void )
{

}

interrupt void Cla1Task8 ( void )
{

}

//
// End of file
//
