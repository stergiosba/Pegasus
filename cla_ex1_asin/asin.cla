//
// Included Files
//
#include "cla_ex1_asin_shared.h"

//
// Defines
//

//
// Globals
//
// Note that the globals defined in the .cla source are global to the cla source
// file.  i.e. they may be shared across tasks. All of the data shared between
// the CLA and the C28x CPU must be defined in the C (or C++) code, and not the
// CLA code.  
//
/*
static inline void matmul(m_elem A[][N], m_elem B[][N], m_elem C[][N])
{
    C[0][0] = A[0][0]*B[0][0] + A[0][1]*B[1][0] + A[0][2]*B[2][0];
    C[0][1] = A[0][0]*B[0][1] + A[0][1]*B[1][1] + A[0][2]*B[2][1];
    C[0][2] = A[0][0]*B[0][2] + A[0][1]*B[1][2] + A[0][2]*B[2][2];
    C[1][0] = A[1][0]*B[0][0] + A[1][1]*B[1][0] + A[1][2]*B[2][0];
    C[1][1] = A[1][0]*B[0][1] + A[1][1]*B[1][1] + A[1][2]*B[2][1];
    C[1][2] = A[1][0]*B[0][2] + A[1][1]*B[1][2] + A[1][2]*B[2][2];
    C[2][0] = A[2][0]*B[0][0] + A[2][1]*B[1][0] + A[2][2]*B[2][0];
    C[2][1] = A[2][0]*B[0][1] + A[2][1]*B[1][1] + A[2][2]*B[2][1];
    C[2][2] = A[2][0]*B[0][2] + A[2][1]*B[1][2] + A[2][2]*B[2][2];
}

static inline void transpose(m_elem A[][N], m_elem AT[][N])
{
    AT[0][0] = A[0][0];
    AT[0][1] = A[1][0];
    AT[0][2] = A[2][0];
    AT[1][0] = A[0][1];
    AT[1][1] = A[1][1];
    AT[1][2] = A[2][1];
    AT[2][0] = A[0][2];
    AT[2][1] = A[1][2];
    AT[2][2] = A[2][2];
}*/

static inline void matmul2(m_elem Df[][N], m_elem S[][N], m_elem C[][N])
{
    C[0][0] = Df[0][0]*(Df[0][0]*S[0][0] + Df[0][1]*S[1][0] + Df[0][2]*S[2][0]) + Df[0][1]*(Df[0][0]*S[0][1] + Df[0][1]*S[1][1] + Df[0][2]*S[2][1]) + Df[0][2]*(Df[0][0]*S[0][2] + Df[0][1]*S[1][2] + Df[0][2]*S[2][2]);
    C[0][1] = Df[1][0]*(Df[0][0]*S[0][0] + Df[0][1]*S[1][0] + Df[0][2]*S[2][0]) + Df[1][1]*(Df[0][0]*S[0][1] + Df[0][1]*S[1][1] + Df[0][2]*S[2][1]) + Df[1][2]*(Df[0][0]*S[0][2] + Df[0][1]*S[1][2] + Df[0][2]*S[2][2]);
    C[0][2] = Df[2][0]*(Df[0][0]*S[0][0] + Df[0][1]*S[1][0] + Df[0][2]*S[2][0]) + Df[2][1]*(Df[0][0]*S[0][1] + Df[0][1]*S[1][1] + Df[0][2]*S[2][1]) + Df[2][2]*(Df[0][0]*S[0][2] + Df[0][1]*S[1][2] + Df[0][2]*S[2][2]);
    C[1][0] = C[0][1];
    C[1][1] = Df[1][0]*(Df[1][0]*S[0][0] + Df[1][1]*S[1][0] + Df[1][2]*S[2][0]) + Df[1][1]*(Df[1][0]*S[0][1] + Df[1][1]*S[1][1] + Df[1][2]*S[2][1]) + Df[1][2]*(Df[1][0]*S[0][2] + Df[1][1]*S[1][2] + Df[1][2]*S[2][2]);
    C[1][2] = Df[2][0]*(Df[1][0]*S[0][0] + Df[1][1]*S[1][0] + Df[1][2]*S[2][0]) + Df[2][1]*(Df[1][0]*S[0][1] + Df[1][1]*S[1][1] + Df[1][2]*S[2][1]) + Df[2][2]*(Df[1][0]*S[0][2] + Df[1][1]*S[1][2] + Df[1][2]*S[2][2]);
    C[2][0] = C[0][2];
    C[2][1] = C[1][2];
    C[2][2] = Df[2][0]*(Df[2][0]*S[0][0] + Df[2][1]*S[1][0] + Df[2][2]*S[2][0]) + Df[2][1]*(Df[2][0]*S[0][1] + Df[2][1]*S[1][1] + Df[2][2]*S[2][1]) + Df[2][2]*(Df[2][0]*S[0][2] + Df[2][1]*S[1][2] + Df[2][2]*S[2][2]);
}

__interrupt void Cla1Task1 ( void )
{
    //Local Variables
    __mdebugstop();

    /*
    RESTART_CLOCK;
    matmul(x, y, z);
    READ_CLOCK(ulCycleCount1);
    RESTART_CLOCK;
    transpose(x, xT);
    READ_CLOCK(ulCycleCount2);
    RESTART_CLOCK;
    matmul(z, xT, K);
    */
    READ_CLOCK(ulCycleCount3);

    RESTART_CLOCK;
    matmul2(x, y, K);
    READ_CLOCK(ulCycleCount1);

    kk++;
}

interrupt void Cla1Task2 ( void )
{

}

interrupt void Cla1Task3 ( void )
{

}

interrupt void Cla1Task4 ( void )
{

}

interrupt void Cla1Task5 ( void )
{

}

interrupt void Cla1Task6 ( void )
{

}

interrupt void Cla1Task7 ( void )
{

}

interrupt void Cla1Task8 ( void )
{

}

//
// End of file
//
